//: [Previous](@previous)

import Foundation
import UIKit

// MARK: Паттерны проектирования
// В своей практике разработчикам часто приходится решать типовые задачи, для реализации которых уже найдены оптимальные пути и шаблоны. Они называются паттернами проетирования.

// Базовые паттерны проектирования под iOS, macOS

// MARK: 1. Паттерн MVC. Фреймворк Cocoa Touch
// MVC расшифровывается как Model-View-Controller (модель_отображение_контроллер) и является основой постороения программных продуктов в среде Xcode. Этот паттерн предпологает полное разделение кода, данных и внешнего вида приложения друг от друга. Каждый из этих элементов создается и управляется отдельно.
// MVC:
// 1. Model (модель) - объекты, обеспечивающие хранение данных ваших приложений и логику их обработки
// 2. View (отображение/представление) - объекты, описывающие различные графические элементы, которые видит пользователь при работе с приложением
// 3. Controller (контроллер) - объекты, обеспечивающие совместную работу "отображения" и "модели"

// Каждый объект который мы создаем в своей программе, может быть легко отнесен к одной из категорий, но при этом не должен реализовывать функции, присущие двум другим

// Все возможности по разработке приложений обеспечивает iOS SDK (software development kit, комплекс средств разработки), который входит в состав Xcode. В состав iOS SDK входит фреймворк Cocoa Touch, который как раз построен на MVC

// MARK: 2. Паттерн Singleton. Класс UIApplication

// Глобальные переменные могут стать значительной проблемой при разработке программ с использованием ООП. Они привязывают классы к их контексту, и повторное использование этих классов в других проектах становится невозможным.
// Шаблон проектирования Singleton подразумевает существование только одного экземпялра класса, который может быть использован в любом другом контексте. Для того чтобы это обеспечить в классе создается единая точка доступа к экземпяру этого класса. Так например мог бы существовать класс Preferences, для доступа к экземпяру которого мы могли бы использовать свойство Preferences.shared. При попытке доступа к данному свойству из любого другого класса будет возвращен один и тот же экземпляр

class Preferences {
    // свойство для доступа к объекту
    static let shared = Preferences()
    
    // произвольные настройки проекта
    var backgroundColor: UIColor = .black
    var defaultUserLogin = "Guest"
}

// получаем класс с настройками с помощью Singleton-свойства
Preferences.shared.defaultUserLogin
Preferences.shared.backgroundColor

// или получаем ссылку на класс и записываем в произвольный параметр
var pref = Preferences.shared
pref.backgroundColor = .blue
Preferences.shared.backgroundColor

// Примером использования класса Sinleton при разработке под iOS может служить класс UIAplication, экземпляр которого является стартовой точкой для всего приложения. Любое создаваемое приложение содержит в себе и использует только один экземпляр класса UIAplication, доступ к которому обеспечивается с помощью шаблона Singleton. Класс UIApplication выполняет большое количество задач, в том числе обеспечивает вывод на экран устройства окна вашего приложения (экземпляр класса UIWindow) и отображение в нем стартовой сцены. Вам как разработчику, никогда не придется самостоятельно создавать экземпляр класса UIApplication, система делает это автоматически, независимо от кода приложения, и постоянно работает фоном
// UIWindow создается автоматически и обеспечивает отображение UI приложений. Мобильные программы обычно имеют только один экземпляр UIWindow, так как одновременно отображается только одно окно (за исключением подключения внемшнего дисплея)

// MARK: 3. Паттерн Delegation. Класс UIApplicationDelegate

// Паттерн Delegation (делегирование) является еще одним очень важным паттерном для iOS-разработчика
// Суть паттерна состоит в том, чтобы один класс делегировал (передавал) ответственность за выполнение некоторых функций другому классу.
// Фреймвор Cocoa Touch очень активно использует делегаты в своей работе, чтобы одни объекты выполняли часть своих функций от лица других




//: [Next](@next)
