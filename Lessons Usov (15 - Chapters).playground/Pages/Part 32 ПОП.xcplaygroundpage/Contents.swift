//: [Previous](@previous)

import Foundation


// Интерфейс (протокол) - это стандарт, описывающий порядок взаимодействия с объектом. Иными словами, это набор требований, которым должен удовлетворять объект, чтобы с ним можно было производить взаимодействие установленным образом.

// Есть три важнейшие причины использования протоколов:
// 1. Целостность типов данных
// 2. Инкапсуляция
// 3. Полиморфизм

// Целостность типов данных
// Использование протоколов обеспечивает целостность типов данных. Другими словами, если некоторый объектный тип подписан на протокол, то с уверенность можно утверждать, что в нем реализованы требования данного протокола

// Инкапсуляция - это подход, при котором данные и методы для работы с этими данными объединяются в единую сущность, при этом скрывая свою внутреннюю реализацию

// пример
// сущность ТВ-шоу
class TVShow {
    //..
}

// протокол описывающий функциональность работы с ТВ-шоу
protocol DisplayShow {
    func getShowList() -> [TVShow]
    func changeShowTo(show: TVShow) -> Void
    var currentShow: TVShow { get }
    // дополнительные требования...
}

// протокол описывающий функциональность управления звуком
protocol ChangeVolume {
    var currentVolume: UInt8 { get set }
    func increase(by: UInt8) -> Void
    func decrease(by: UInt8) -> Void
    // дополнительные требования...
}

// сущность Телевизор принимает протоколы к исполнению

class TV: DisplayShow, ChangeVolume {
    var currentShow: TVShow = TVShow()
    var currentVolume: UInt8 = 5
    
    func getShowList() -> [TVShow] {
        return [currentShow]
    }
    
    func changeShowTo(show: TVShow) {
        self.currentShow = show
    }
    
    func increase(by: UInt8) {
        self.currentVolume += by
    }
    
    func decrease(by: UInt8) {
        self.currentVolume -= by
    }
    
    // реализация методов и свойтсв протоколов
}


// Полифморфизм
// полиморфизм - это подход, предусматривающий возможность взаимодействия с различными типами данных единым образом в отсутствии информации о конкретном типе данных объекта

class DVDPlayer: ChangeVolume {
    // реализация методов и свойств протоколов...
    var currentVolume: UInt8 = 5
    
    func increase(by: UInt8) {
        self.currentVolume += by
    }
    
    func decrease(by: UInt8) {
        self.currentVolume -= by
    }
}

// структура универсального пульта переключения громкости
struct UniversalManager {
    var currentDevice: ChangeVolume
    mutating func increaseVolume(by: UInt8) -> Void {
        self.currentDevice.increase(by: by)
    }
    //..
}

// начнем работы с DVD плеером
var player = DVDPlayer()
var manager = UniversalManager(currentDevice: player)
manager.increaseVolume(by: 1)
player.currentVolume

// переключимся на работу с телевизором
var someTV = TV()
manager.currentDevice = someTV
manager.increaseVolume(by: 3)
someTV.currentVolume

// Таким образом можно настроить значение типа UniverslaManager хоть на работу с TV, хоть на работы с DVDPlayer. В этом и есть суть полиморфизма. Наш универсальный пульт может взаимодействовать с любым объектом, не имея информации о его конкретном типе

// Подобного результата можно добиться и без протоколо, с помощью наследования классов. Но Swift не поддерживает множественное наследование классов, зато приветсвует его для протоколов

// Множественное наследование - это наследование от двух и более родителей

// Протокол-ориентированное программирование

/*
 Основные принципы ООП:
 - Наследование
 - Инкапсуляция
 - Полиморфизм
 */

// Разница ООП и ПОП (Swift)
/*
 1. В Swift отсутствует множественное наследование
 Классы могут наследоваться только от одного родителя, а структуры вообще не могут иметь родительские объектные типы. Но при этом есть возможность подписывать объектные типы на множество протоколов. Таким образом Swift позволяет использовать множественное наследование, но только при работе с протоколами.
 2. Протоколы позволяют содержать реализацию по умолчанию. (с помощью расширений extension).
 Таким образом, мы можем создать множество протоколов, при необходимости указать реализацию по умолчанию и при создании объектного типа подписать его на данные протоколы, с ходу обеспечив тип функциональной составляющей. Не написав ни строчки кода в теле объектного типа, вы наделяете его возможностями
*/

// Суть протокол-ориентированного прогаммирования состоит в том, что в первую очередь описываются протоколы, а уже потом объектные типы, принимающие их к реализации

/*
 Правила выбора между классом и структурой
 Правило №1
 Отдавайте предпочтение структурам, нежели классам
 Правило №2
 Используйте классы только тогда, когда вам действительно нужны их особенности
 
 Причина выбрать структуру №1. Безопасность
 Структуры безопаснее классов. Множественные копии объектов, в отличии от множественных ссылок, не способны привести к случайному, неконтролируемому изменению данных
 Причина выбрать структуру №2. Утечки памяти
 Причина выбрать структуру №3. Раздутые объектные типы
 Причина выбрать структуру №4. Структуры быстрее классов
 */
// example №4
func getMinutesDifferenceFromTwoDates(start: Date, end: Date) -> Double {
       Double(end.timeIntervalSince1970 - start.timeIntervalSince1970)
}

class ValueClass {
    var value: Int = 0
}

struct ValueStruct {
    var value: Int = 0
}




var operationArray = Array(1...100_000_000)

// опыт с классом

//var a = ValueClass()
//
//for _ in operationArray {
//    a.value += 1
//}



// опыт со структурой
var startTime = Date()
var b = ValueStruct()

for _ in operationArray {
    b.value += 1
}
var finishTime = Date()


getMinutesDifferenceFromTwoDates(start: startTime, end: finishTime)

// Причина выбрать класс №1. Логичная передача объектов по ссылке. Стоит использовать класс в тех случаях, когда однозначно понятно, что лучше передавать объект по ссылке.

struct User {
    var id: Int
}

class UserController {
    var users: [User] = []
    func add(user: User) {
        
    }
    func removeBy(userID: Int) {
        
    }
    // ...
}

// Причина выбрать класс №2. Совместимость с Objective-C

//: [Next](@next)
