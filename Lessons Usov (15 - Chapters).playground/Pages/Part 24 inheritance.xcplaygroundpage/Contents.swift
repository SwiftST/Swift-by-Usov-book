//: [Previous](@previous)

import Foundation

// Наследование - один из принципов методологии объектно-ориентированного программирования. Подразумевает что классы могут быть созданы не с нуля, а на базе уже существующих классов. При этом все свойства, методы и сабскрипты старшего класса включаются в состав нового.
// При наследовании старший класс называется суперклассом (базовым или родительским), а новый (созданный на его основе) подклассом

// Синтаксис
/*
 class SuperClass {
    body surepclass
 }
 class SubClass: SuperClass {
    body subclass
 }
 */

// Example
// superclass
open class Quadruped {
    var type = ""
    var name = ""
    
    func walk() {
        print("walk")
    }
}
// subclass
class Dog: Quadruped {
    func bark() {
        print("woof")
    }
}
var dog = Dog()
dog.type
dog.walk()
dog.bark()

// класс может быть суперклассом для произвольного количество подклассов

// Доступ к наследуемым характеристикам
// Доступ к наследуемым свойствам родительского класса реализуется так же как и к собственным элементам данного дочернего класса, то есть с использованием ключевого слова self

// example
class SomeDog: Quadruped {
    func bark() {
        print("woof")
    }
    func printName() {
        print(self.name)
    }
}
var someDog = SomeDog()
someDog.name = "Rex"
someDog.printName()

// Переопределение наследуемых элементов
// Подкласс может создавать собственные реализации свойств, методов и сабскриптов, наследуемых от суперКласса. Такие реализации называются переопределенными. Для переопределения параметров суперкласса в подклассе необходимо указать ключевое слово override перед определением элемента.

// переопределение методов
class NoisyDog: Dog {
    override func bark() {
        print("woof")
        print("woof")
        print("woof")
    }
}
var badDog = NoisyDog()
badDog.bark()
// c помощью ключевого слова override мы сообщаем Swift, что метод bark() в классе NoisyDog имеет собственную реализацию

// доступ к переопределенным элементам суперКласса
// несмотря на то что переопределение изменяет реализацию свойств, методов и сабскриптов, Swift позволяет осуществляь доступ внутри дочернего клссса к переопределенным элементам суперкласса. Для этого в качестве префикса имени элемента вместо self используется super

class NoysyDodTwo: Dog {
    override func bark() {
        for _ in 1...3 {
            super.bark()
        }
    }
}
var badDogTwo = NoisyDog()
badDogTwo.bark()

// переопределенный метод с именем someMethod() может вызвать одноименный метод суперкласса, используя конструкцию super.someMethod() внутри своей реализации (в коде переопределенного метода)
// переопределенное свойство someProperty может получить доступ к свойству суперкласса с таким же именем, используя конструкцию super.someProperty внутри реализации своего геттера или сеттера
// переопределенный сабскрипт someIndex может обратиться к сабскрипту суперкласса с таким же форматом индекса, используя конструкцию super[someIndex] внутри реализации сабскрипта

// Переопределение инициализаторов
// Инициализаторы являются такими же наследуемыми элементами как и методы
// Если определяем инициализатор с уникальными для подкласса и суперкласса набором аргументов, то не переопределяем иницилазатор а объявляем новый
// Если подкласс имеет хотя бы один собственный инициализатор, то инициализаторы родительского класса не наследуются.
// для вызова инициализатора суперкласса внутри реализации подкласса необходимо использовать конструкцию super.init()

// example
class AnotherDog: Quadruped {
    override init() {
        super.init()
        self.type = "dog"
    }
    func bark() {
        print("woof")
    }
    func printName() {
        print(self.name)
    }
}
var anotherDog = AnotherDog()
anotherDog.type

// прежде чем получить доступ к наследуемым свойствам в переопределенном инициализаторе, необходимо вызвать инициализатор родителя. Он выполняет инициализацию всех наследуемых свойтсв. ЕСли этого не сделать будет ошибка
// если в подклассе есть собственные свойства, которых нет в суперклассе, то их значение необходимо указать до вызова инициализатора родительского класса

// Переопределение наследуемых свойств

// Хранимые свойства переопределить нельзя

// Модификатор final - позоляет защитить реализацию класса целиком или его отдельных элементов.

// final class
// final var
// final func
// finak subscript

// При защите реализации его наследование в другие классы становится невозможным. Для элементов класса - их наследование происходит, но переопределение становится недоступным


// Подмена экземпляров класса
// Наследование позволяет заменять теребуемые экземпляры СуперКласс экземплярами его подклассов
var animals: [Quadruped] = []
var someAnimal = Quadruped()
var myDog = Dog()
var sadDog = NoisyDog()
animals.append(someAnimal)
animals.append(myDog)
animals.append(sadDog)


// Приведение типов
// Для анализа классов в единой иерархии существует механизм, называемый приведением типов
// путем приведения типов можно выполнить следующие операции:
// проверить тип конкретного экземпляра класса на соответствие некоторому типу или протоколу
// преобразовать тип конкретного экземпляра в другой тип той же иерархии классов

// проверка типа
// проверка типа экземпляра класса производится с помощью оператора is. Оператор возвращает true когда тип проверяемого экземпляра является указанным после оператора классом или наследует его

for animal in animals {
    if animal is Dog {
        print(animal.self)
    }
}

// преобразование типа
// Объявленный ранее массив animals содержит экземпляры типов входящих в одну иерархию Quadruped. При этом методы присущие другим классам Dog, NoisyDog (bark) не доступны в данной реализации, поскольку Swift подразумевает что мы работаем только с экземплярами Qudruped
// для того чтобы преобразовать тип и сообщить Swift что данный элемент является экземпляром определенного типа исльзуется метод as? и as!

// as? NameClass возвращает либо экземпляр либо nil в случае неудачноого преобразования
// as! NameClass производит принудительное извлечение опционала, в слуяае неудачи вызовет ошиьку

for animal in animals {
    if var item = animal as? NoisyDog {
        item.bark()
    } else if let item = animal as? Dog {
        item.bark()
    } else {
        animal.walk()
    }
}



//: [Next](@next)
