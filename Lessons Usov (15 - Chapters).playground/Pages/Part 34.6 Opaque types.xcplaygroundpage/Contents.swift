//: [Previous](@previous)

import Foundation

// Opaque types (непрозрачные типы)

// Задача - описать несколько типов транспортных средств

// начнем с реализации протокола
protocol Vehicle {
    var uid: Int { get set }
}
// основываясь на протоколе, мы сможем реализовать необходимые структуры
// Машина
struct Car: Vehicle {
    var uid: Int
}
// грузовик
struct Truck: Vehicle {
    var uid: Int
}

// функция возвращающая экземпляр одной из структур, тип возвращаемого значения определим используя протокол Vehicle
func getCar() -> Vehicle {
    return Car(uid: 93)
}
getCar()

// усложни код. предположим что каждый тип транспортного средства имеет свою систему идентификации по уникальным номерам и для свойства uid требуется использовать значения различных типов в различных реализациях протокола Vehicle. Реализуем это с помощью связанного типа

protocol VehicleOne {
    // связанный тип
    associatedtype Identifier
    var uid: Identifier { get set }
}

// Машина
struct CarOne: VehicleOne {
    var uid: Int
}
// грузовик
struct TruckOne: VehicleOne {
    var uid: String
}

// теперь структуры Car и Truck используют различные типы данных для свойства uid
// XCode сообщает об ошибке в функции getCarOne()
/*
 Причины:
 1. Протокол Vehicle имеет связанный тип, а реализующие его структуры используют различные типы данных для свойства uid(String и Int)
 2. Для того чтобы определить возвращаемое функцией getCar() значение, компилятор не анализирует код в ее теле. В обычных условиях тип значения должен явно определяться из сигнатуры функции
 3. В текущей реализации функции getCar() потенциально может вернуть значение любого типа данных, подписанного на протокол Vehicle. При этом заранее неизвестно значение какого типа должно быть возвращено
 4. Потенциально может произойти ситуация, при которой getCar() возвращает значение типа Car, когда вы ожидаете значение типа Truck (или наоборот)
 */

//func getCarOne() -> VehicleOne {
//    return CarOne(uid: 93)
//}

// Компилятор основываясь на данных, которыми он обладает не может принять решение значеник какого конкретно типа данных будет возвращено функцией

// Решение проблемы
// Вариант 1. Использовать дженерики

func getCarOne<T: VehicleOne>() -> T {
    return CarOne(uid: 93) as! T
}

var someVehicle: CarOne = getCarOne()
someVehicle.uid
// тип возвращаемого параметра опредеятся явно при вызове функции
// такой подход будет рабочим до тех пор  пока не попытаться проинициализировать результат работы функции параметру Truck

//let anotherVehicle: Truck = getCarOne()

// При испльзовании дженериков тип данных итогового значения определяется при вызове функции

// Вариант 2. Использовать непрозрачные типы (Opaque types)
// При реализации функции getCar тип возвращаемого значения может быть указан как протокол Vehicle с ключевым словом some

func getCarTwo() -> some VehicleOne {
    return CarOne(uid: 54)
}

let myCar = getCarTwo()
// ключевое слово some, говорит о отм, что Vehicle является непрозрачным типом (Opaque type), с помощью чего компилятор заранее анализирует тело функции и определяет конкретный тип возвращаемого значения

// Универсальные типы (дженерики_ и непрозрачные типы связаны между собой. При использовании дженериков конкретный тип возвращаемого значения определяет тот, кто вызывает функцию, а при использовании Opaque types конкретный тип определяется реализацией функции ( в ее теле)

// Generic
func getCarThree<T: VehicleOne>() -> T {
    return CarOne(uid: 22) as! T
}

// Тип возвращаемого значения определяется тут
let a: CarOne = getCarThree()

// Opaque type
func getCarFour() -> some VehicleOne {
    // тип возвращаемого значения определяется тут
    return CarOne(uid: 2)
}

let b = getCarFour()

// В первом случае заполнитель типа (T) заменяется на конкретный тип данных при вызове функции. В свою очередь при использовании Opaque type тип данных возвращаемого значения определяется в ходе анализа функции еще до ее вызова
// Функция использующая непрозрачный тип, всегда будет возвращать значение одного конкретного типа данных. Код указанный ниже недопустим:

//func getCarFive(by number: Int) -> some VehicleOne {
//    switch number {
//    case 1:
//        return CarOne(uid: 3)
//    default:
//        return TruckOne(uid: "dv")
//    }
//}
// Ошибка! такой код не допустим так как функция должна возвращать значение одного конкретного типа данных, а не одного из

// Opaque types позволяют указывать тип возвращаемого функцией значения с помощью протокола, использующего связанные типы (или ключевое слово Self) в своей реализации
// Opaque types позволяют определять тип возвращаемого значения внутри самой функции


//: [Next](@next)
